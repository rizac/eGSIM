<p>
eGSIM is a
<a target='_blank' href='https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_Web_services'>REST API</a>:
i.e., along the lines of popular seismological web services (see e.g. the
<a target="_blank" href="https://www.fdsn.org/webservices/FDSN-WS-Specifications-1.1.pdf">FDSN protocol</a>),
it can be used via <i>requests</i> issued by a client (eGSIM user) in several ways such as e.g.
the browser GUI, command line applications like <code>wget</code> or client code 
(e.g. Python's <code>urllib.request</code>). Requests require:
</p>
<ol>
<li>An endpoint, i.e. an URL denoting a specific service
<li>A method (GET vs POST) defining the type of request
<li>Parameters for customizing the desired response data
</ol>
<p>
The web server processes the request and returns a <i>response</i> to the client in specific
formats.
This document describes eGSIM request and responses in details to help the user working
with the API.
</p>


<h3 id="requestendpoints">Requests endpoints</h3> 
<p>
The following base URI pattern has to be used for each request:
</p>

<p>
<code class='pre'>{{ baseurl }}/&lt;service&gt;</code>
</p>

<p>
where {{ baseurl }} is the base eGSIM URL (if you are viewing this document online, {{ baseurl }}
is the browser address without the last "/apidoc" part)

and <code>&lt;service&gt;</code> is one of the following:
</p>
<ul>
	<li><code>{{ egsim_data.GSIMS.path }}</code> for <a href="#gsimselection"> Model Selection</a> </li>
	<li><code>{{ egsim_data.TRELLIS.path }}</code> for <a href="#trellisplots"> Model-to-Model Comparison</a> </li>
	<li><code>{{ egsim_data.RESIDUALS.path }}</code> for <a href="#residualanalysis"> Model-to-Data Comparison</a> </li>
	<li><code>{{ egsim_data.TESTING.path }}</code> for <a href="#testing"> Model-to-Data Testing</a> </li>
</ul>


<h3 id="requestmethods">Requests methods</h3>
<p>
eGSIM services can be invoked using the two standard HTTP methods: GET or POST.
Typically, POST request are defined to send data to create/update a resource on the server.
In eGSIM, both methods perform the same task of querying data. We suggest to use
the GET method for simple reuqests with few parameters, and POST otherwise.
</p>

<h4>GET method</h4>
<p>
Requests issued with the GET method simply concatenate the parameters names and
values directly in the URL:
</p>

<p>
<code>{{ baseurl }}/&lt;service&gt;?<span class="token key atrule">name1</span>=<span class="token number">value1</span>&amp;<span class="token key atrule">name2</span>=<span class="token number">value2</span></code>
</p>

<p>
The portion of string after the question mark ? is called <i>query string</i>: as you can see,
some characters are not <i>safe</i>, because they have special meanings and
they will not be interpreted as they are (e.g. <span class='token string'>&amp;</span>)
. The only safe characters are the alphanumeric ones (letters lower or uppercase, and numbers),
all other characters should be
<a href="https://en.wikipedia.org/wiki/Percent-encoding" target='_blank'>percent encoded</a>.
E.g., in Python you can use the <code>urllib's quote</code> function:
</p>
<pre><code class="language-python">from urllib.parse import quote
dip = 60.5
vs30 = [700, 800]
# convert to strings:
dips = str(dip)  # "60.5"
vs30s = ",".join(str(_) for _ in vs30)  # "700,800"
# build query string:
query_str = '?' + 'dip=' + quote(dips, '') + '&amp;' + 'vs30=' + quote(vs30s, '')
</code></pre>
<p>
Percent encoding the parameters in a GET request can become quite cumbersome
for complex parameter sets. In case,
the user might be interested to issue POST requests instead.
</p>
<p class='footnote'>
Note: These characters are <i>very likely</i> to be safe, but we cannot guarantee
they will always be (do not encode them at your risk):
</p>
<p class='footnote'>
<span class='token string' style='letter-spacing: 1rem; font-size:120%'>{{ query_params_safe_chars }}</span>
</p>



<h4>POST method</h4>
<p>
Requests issued with the POST method should use the usual URL pattern:
<code>{{ baseurl }}/&lt;service&gt;</code>
and provide the parameters set by means of additional data as text in
<a target="_blank" href="https://en.wikipedia.org/wiki/JSON#Data_types.2C_syntax_and_example">JSON</a> or
<a target="_blank" href="https://en.wikipedia.org/wiki/YAML#Example">YAML</a> format.
This releases the user from encoding parameters and avoids writing long query strings
as all parameters are provided in an external file. How to create a POST request
depends  on the software or programming language used. Here a code snippet for Python (see 
<a href='https://docs.python.org/3/howto/urllib2.html' target="_blank">HOWTO Fetch Internet Resources Using The urllib Package</a> for details):
</p>

<pre><code class="language-python">import json
import yaml  # needs PyYAML installed
# imports for Python3  (comment/remove in Python2):
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError
# imports for Python2 (comment/remove in Python3):
from urllib2 import Request, urlopen, URLError, HTTPError

# 1) Request using the GET method:
req = Request("eGSIM endpoint URL with encoded special characters, if any")

# 2a) Request using the POST method, assuming JSON text file:
with open('/path/to/my/file.json', 'r') as stream:
    jsondata = json.load(f)
req = Request("write here your eGSIM endpoint URL", data=jsondata)

# 2b) Request using the POST method, assuming YAML or JSON text file
#     (YAML is a superset of JSON and thus this works also with JSON files):
with open('/path/to/my/file.yaml', 'r') as stream:
    yamldata = yaml.safe_load(stream))
req = Request("write here your eGSIM endpoint URL", data=yamldata)</code></pre>



<h3 id="requestparameters">Request parameters</h3>

<p>
eGSIM supports the following parameter types in a request:
</p>


<ul>
<li>numeric
<li>text (denoted as <code>string</code>)
<li>boolean (<code>true</code> or <code>false</code>)
<li>UTC date-time (in ISO format without timezone, e.g.:
<code>2016-01-30T23:15:11</code> or <code>2016-01-31</code>)
<li>arrays (vectors) of the previous types
<li>numeric ranges (i.e., equally spaced numeric arrays) in the
<a href="https://www.mathworks.com/help/matlab/ref/colon.html#bvhfyce" target="_blank">MATLAB<sup>&reg;</sup> format</a>
<code>start:step:end</code>
(e.g. <code>0:0.1:0.3</code> results in the sequence of values 0, 0.1, 0.2, 0.3)
</ul>

<p>
<b>Example</b> assuming a service with endpoint <code>http://egsim.org/example</code>, requiring
the following parameters:
</p>

<ul>
<li>dip (numeric scalar)
<li>Vs<sub>30</sub> (numeric array)
<li>mag (numeric array)
<li>start (date-time)
</ul>
<p>
Then a user request might look like this:
</p>
<table>
<tr>
	<td>GET</td>
	<td colspan="2">http://egsim.org/example?dip=45&vs30=560,760&mag=3:0.5:5&start=2016-12-31T12:00:00</td>
<tr>
</tr>
	<td>GET (safe)</td>
	<td colspan="2">http://egsim.org/example?dip=45&vs30=560<span class='token string'>%2C</span>760&mag=3<span class='token string'>%3A</span>0.5<span class='token string'>%3A</span>5&start=2016-12-31T12<span class='token string'>%3A</span>00<span class='token string'>%3A</span>00
	<br><span class='text-muted small'>(Note <span class='token string'>percent encoded</span> characters)</span>
	</td>
</tr>
<tr>
	<td rowspan="3">POST</td>
	<td colspan="2">http://egsim.org/example</td>
</tr>
<tr>
	<td style='border-color:transparent'>data (YAML file)</td><td style='border-color:transparent'>data (JSON file)</td>
</tr>
<tr>
	<td><pre><code class="language-yaml">dip: 45
vs30:
 - 560
 - 760
mag: "3:0.5:5"
start: "2016-12-31T12:00:00"</code></pre>
	</td>
	<td><pre><code class="language-json">{
  "dip": 45, 
  "vs30": [560, 760],
  "mag": "3:0.5:5",
  "start": "2016-12-31T12:00:00"
}</code></pre>
	</td>
</tr>
<tr>
	<td>Web GUI components</td>
	<td colspan="2">
		<div style='white-space: nowrap'>
			<span class='ml-2'>Dip</span>
			<input type="number" value="45"/><br>
			<span class='ml-2 mr-1'>Vs<sub>30</sub></span>
			<input type="text" value="560 760"/><br>
			<span class='ml-2 mr-1'>Mag</span>
			<input type="text" value="3:0.5:5"/><br>
			<span class='ml-2 mr-1'>Start</span>
			<input type="text" value="2016-12-31T12:00:00"/>
		</div>
	</td>
</table>
<div class='footnote'>
Notes:
<ul>
<li>In YAML and JSON format, numeric ranges
and date-times are not fully supported and should be
input as strings with quotes (see example above).
(YAML with Python seems to recognize date-times without quotes, but we suggest
to type them as quoted strings for safety)
<li>From within an input component of the Web GUI, 
<b>spaces or commas</b> are both recognized as array element separators. Array can be optionally
typed in JSON format as well, with leading and trailing square brackets '[' ']'
</ul>
</div>

<p>
The full description of the parameters and their constraints will be given in each service specific
section below.
</p>



<h3 id="responsedata">Response data</h3>

<h4 id="request-format">Formats</h4>

<p>
All eGSIM services can return data at the least in CSV
and JSON formatted text (bytes sequences). 
JSON is by far preferable in web applications
(the eGSIM web GUI for instances requests and processes data in this format), and CSV files have
the advantage to be easily visualizable in widely used spreadsheet softwares.
However, for client code processing response data, both formats
are widely supported in most languages (see e.g., the MATLAB<sup>&reg;</sup>
<a href="https://www.mathworks.com/help/matlab/ref/jsondecode.html" target="_blank">jsonencode</a> and 
<a href="https://www.mathworks.com/help/matlab/ref/csvread.html" target="_blank">csvread</a>
functions, or Python 
<a href="https://docs.python.org/3/library/json.html" target="_blank">json</a> and 
<a href="https://docs.python.org/3/library/csv.html" target="_blank">csv</a>
standard libraries)
</p>

<p>
All eGSIM services accept the following parameters in the request which will
dictate the response format:
</p>

<table class='request'>
	{% include "apidoc/request_template.html" with form=egsim_data.FORMAT.form %}
</table>

(the parameters above will be omitted for simplicity in the remainder of the document)

<h4 id="request-errors">Errors</h4>

<p>
Unsuccessful requests might fail for several reasons. In case of client
or server errors, such as e.g. bad or missing parameters, eGSIM always returns responses
in JSON formatted byte strings following the <a href="https://google.github.io/styleguide/jsoncstyleguide.xml#Reserved_Property_Names_in_the_error_object" target="_blank">
google API specification</a>. Example:
</p>

<pre><code class="language-json">{
	"error": {
		"code": 400,
		"message": "input validation error",
		"errors": [
			{
		    	"domain": "magnitude",
		    	"message": "This field is required.",
		    	"reason": "required"
		  	},
		  ...
		]
	}
}</code></pre>

<div class='footnote'>
Notes:
<ul>
	<li>the code and the message are standard HTTP numeric status codes &ge;400 and &le; 500 and
	text. For invalid parameters, the code is 400. In this case the parameter 'errors' might
	be provided (in all other cases it's missing), and it is a list of objects with these
	properties: domain (indicating the parameter name raising the error), message
	(indicating the error message) and reason (indicating the error reason)
</ul>
</div>


<p>
For instance, this code snippet modified from the
<a href="https://docs.python.org/3/howto/urllib2.html" target="_blank">standard Python how-to reference</a>
shows how to issue a request to a eGSIM service and catch potential errors in both Python2 and 3
(tested with Python 2.7 and 3.6):
</p>

<pre><code class="language-python">import json

# imports for Python3  (comment/remove in Python2):
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError

# imports for Python2 (comment/remove in Python3):
from urllib2 import Request, urlopen, URLError, HTTPError

req = Request("write here your eGSIM endpoint URL")
try:
    data = json.loads(urlopen(req))
except HTTPError as e2:
    # handle HTTP errors because of a server or client error, e.g.:
    print("Http error %d" % e2.code)
    # If you want to dig into details,
    # load the JSON formatted response into a Python dict:
    errordict = json.loads(e2.read())['error']
    # now you can access fields such as
    # errordict['message'], errordict.get('errors', [])
except URLError as e1:
    # handle general url errors like network errors. e.g.:
    print("Url error. Reason: %s" % e1.reason)
</code></pre>
